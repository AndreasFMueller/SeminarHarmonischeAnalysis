%
% teil3.tex -- Beispiel-File für Teil 3
%
% (c) 2020 Prof Dr Andreas Müller, Hochschule Rapperswil
%
% !TEX root = ../../buch.tex
% !TEX encoding = UTF-8
%
\section{JPEG Kompression
\label{jpeg:section:kompjpeg}}
\rhead{JPEG Kompression}
Um Bilder mit der DCT transformieren zu können, ist eine Vorverarbeitung nötig. 
in der Vorverarbeitung wird die Farbraumumrechnung um eine bessere Kompression zu erreichen.
Zudem wird das ganze Bild in \(8\times8\) Pixelblöcke unterteilt, da die zweidimensionale DCT damit arbeitet.

\subsection{Farbraumumrechnung
\label{jpeg:subsection:farbraumumrechnung}}
Ein weit verbreiteter Farbmodell ist das Rot-Grün-Blau-Modell (RGB), dabei wird eine Pixelfarbe mit einem Rot-, Grün- und Blauwert additive erzeugt.

Beim JPEG-Standart wechselt man die Basis, in der die Farben dargestellt werden und benutzt statt RGB das YCbCr-Modell.
In diesem Modell werden die Helligkeit (Luminaz Y), sowie die Farbigkeit (Chrominanz).
\(C_b\) von Grau in Richtung Blau/Gelb und \(C_r\) von Grau nach Rot/Türkis.

Die Transformation wird gemacht, weil unsere Augen Empfindlicher sind auf Helligkeitsunterschiede, als auf Farbunterschiede.
Damit lassen sich, nach einer DCT, die Koeffizienten aus den \(C_b\) und \(C_r\) Matrizen stärker Quantisieren als die in der Y Matrix.
Der beschriebene Frabraum wechsel lässt sich
\begin{equation}
    \begin{pmatrix}
        Y\\
        C_b\\
        C_r\\
    \end{pmatrix}
    \thickapprox
    \begin{pmatrix}
        0\\
        128\\
        128\\
    \end{pmatrix}
    +
    \begin{pmatrix}
        0.299 & 0.587 & 0.114\\
        -0.168736 & -0.331264 & 0.5\\
        0.5 & -0.418688 & -0.081312\\
    \end{pmatrix}
    \cdot
    \begin{pmatrix}
        R\\
        G\\
        B\\
    \end{pmatrix}
    \label{jpeg:equationfrab}
\end{equation}
berechnen.
Durch begrenzte Rechengenauigkeit und Rundungsfehler entstehen hier Datenverluste.

\subsection{Tiefpassfilter und Unterabtastung
\label{jpeg:subsection:tiefpass}}

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{papers/jpeg/pictures/ycbcr.pdf}
    \caption{Von links Original, Luminanz, Chrominanz Blau/Gelb und Rot/Türkis
        \label{jpeg:fig:ycbcr}}
\end{figure}

Im Abschnitt \ref{jpeg:subsection:farbraumumrechnung} wurde beschrieben, dass die Farbauflösung der \(C_b\) und \(C_r\) für Menschen deutlich geringer ist wie in Abb. \ref{jpeg:fig:ycbcr} ersichtlich.
Dazu werden sie Tiefpass gefiltert, zudem üblicherweise vertikal und horizontal um den Faktor 2 Unterabgetastet, was einer 4 fachen Datenreduktion entspricht.

\subsection{Tiling
\label{jpeg:subsection:tiling}}
Beim Tiling wird das Bild in jeweils \(8\times8\) Pixel grosse Blöcke unterteilt.
Da normalerweise die Seitenlängen eines Bildes sich nicht durch 8 teilen lässt, werden die Restlichen Zeilen bzw. Spalten jeweils aufgefüllt.
Wie das auffüllen geschieht ist im JPEG-Standard nicht festgelegt, es wird jedoch die letzte Pixel-Zeile oder -Spalte jeweils sooft zu wiederholen bis es aufgeht.
Wie in Abb. \ref{jpeg:fig:tiling} ersichtlich.
Auf den einzelnen Blöcken wird nun die DCT angewendet.

\begin{figure}
    \centering
    \includegraphics[width=90mm]{papers/jpeg/pictures/unterteilung.pdf}
    \caption{Bildeinteilung und Erweiterung
        \label{jpeg:fig:tiling}}
\end{figure}

\begin{table}[b]
    \centering
    \begin{tabular}{llllllll}
        134.49 & 132.21 & 130.94 & 130.18 & 130.44 & 129.68 & 126.98 & 124.6  \\
        137.73 & 137.73 & 138.85 & 139.71 & 138.73 & 134.44 & 127.84 & 122.32 \\
        148.5  & 146.78 & 144.76 & 143.9  & 142.36 & 137.31 & 131    & 126.14 \\
        155.37 & 150.22 & 143.14 & 138.57 & 136.55 & 135.79 & 133.58 & 132.72 \\
        153.04 & 148.47 & 141.88 & 138.08 & 135.54 & 134.78 & 132.79 & 131.07 \\
        146.95 & 145.43 & 144.16 & 142.64 & 140.86 & 136.3  & 129.45 & 124.89 \\
        149.99 & 149.22 & 148.46 & 147.7  & 144.74 & 138.07 & 129.47 & 123.85 \\
        160.7  & 156.66 & 151.9  & 147.7  & 143.03 & 138.07 & 132.9  & 128.61
    \end{tabular}
    \caption{Beispiel Originalwerte aus 8x8 Pixelblock
        \label{jpeg:tab:orgblock}}
\end{table}

\subsection{Quantisierung
\label{jpeg:subsection:quantisierung}}
Bei allen verlustbehafteten Komprimierungsverfahren entsteht die eigentliche Datenreduktion erst bei der Quantisierung.
Dazu werden die Koeffizienten aus der DCT Matrix \ref{jpeg:tab:dctblock} mit einer Quantisierungsmatrix elementweise dividiert und auf den nächsten ganzzahligen Wert gerundet.
Diese ist für die Qualität und der Menge der reduzierten Daten verantwortlich.
\begin{equation}
    F^Q(x,y)
    =
    round \left(
    \frac{F(x,y)}{Q(x,y)}
    \right)
\end{equation}
dabei ist \(F^Q\) die resultierende Matrix, \(F\) ist der transformierte Pixelblock und \(Q\) die Quantisierungsmatrix.
In \ref{jpeg:tab:quantblock} sind die Werte des Beispielblocks Quantisiert
Bei diesem Schritt findet die Irrelevanzreduktion statt.

Das Auge ist empfindlicher auf hohe Farbunterschiede von benachbarten Pixel, das sind die tiefen Frequenzen in der DCT Matrix.
Daher werden diese weniger Reduziert als die hohen, man sollte dafür eine optimale Tabelle verwenden.

Da der JPEG-Standard das nicht vorgibt, muss die verwendete Tabelle im Header des Files mit abgelegt werden.
In Tabelle \ref{jpeg:tab:quant} ist eine gängige für die Luminanz und eine für die Chrominanzen ersichtlich.

\begin{table}[t]
    \centering
    \begin{tabular}{llllllll}
        1110.12 & 54.38  & -7.7  & 9.19  & 0.3   & 0.12  & 0.21  & -0.14 \\
        -27.43  & -15.67 & 0.12  & 0.19  & -0.19 & -0.02 & 0.09  & 0.18  \\
        -8.46   & -1.62  & -8.06 & -0.66 & -0.01 & 0.5   & 0.08  & 0.43  \\
        -18.53  & -8.46  & -0.58 & -0.21 & -0.29 & -0.08 & 0.38  & -0    \\
        0.05    & 0.1    & 15.43 & 0.02  & -0.13 & 0.31  & 0.07  & -0.35 \\
        -0.54   & -0.46  & 0.39  & 0.16  & 0.32  & -0.51 & 0.22  & 0.03  \\
        0.82    & 0.61   & 0.68  & 0.22  & 0.07  & -0.03 & 0.03  & 0.29  \\
        0.88    & 0.51   & -0.53 & 0.08  & 0.16  & 0.09  & -0.37 & -0.1 
    \end{tabular}
    \caption{Beispiel 8x8 Pixelblock nach DCT
        \label{jpeg:tab:dctblock}}
\end{table}

\begin{table}[]
    \centering
    \begin{tabular}{llllllll}
        69 & 5  & -1 & 1  & 0  & 0  & 0  & 0 \\
        -2 & -1 & 0  & 0  & 0 & 0 & 0  & 0  \\
        -1 & 0 & -1 & 0 & 0 & 0  & 0  & 0  \\
        -1 & 0 & 0 & 0 & 0 & 0 & 0  & 0 \\
        0  & 0  & 0  & 0  & 0 & 0  & 0  & 0 \\
        0 & 0 & 0  & 0  & 0  & 0 & 0  & 0  \\
        0  & 0  & 0  & 0  & 0  & 0 & 0  & 0  \\
        0  & 0  & 0 & 0  & 0  & 0  & 0 & 0
    \end{tabular}
     \caption{Beispiel 8x8 Pixelblock nach der Quantisierung
        \label{jpeg:tab:quantblock}}
\end{table}

\begin{table}[b]
    \centering
    \begin{tabularx}{0.47\linewidth}{|X|X|X|X|X|X|X|X|}
        \hline
        16 & 11 & 10 & 16 & 24  & 40 & 51 & 61    \\ \hline
        12 & 12 & 14 & 19 & 26  & 58 & 60 & 55    \\ \hline
        14 & 13 & 16 & 24 & 40  & 57 & 69 & 56    \\ \hline
        14 & 17 & 22 & 29 & 51  & 87 & 80 & 62    \\ \hline
        18 & 22 & 37 & 56 & 68  & 109 & 103 & 77  \\ \hline
        24 & 35 & 55 & 64 & 81  & 104 & 113 & 92  \\ \hline
        49 & 64 & 78 & 87 & 103 & 121 & 120 & 101 \\ \hline
        72 & 72 & 95 & 98 & 112 & 100 & 103 & 99  \\ \hline        
    \end{tabularx}
    \qquad
    \begin{tabularx}{0.47\linewidth}{|X|X|X|X|X|X|X|X|}
        \hline
        17 & 18 & 24 & 47 & 99 & 99 & 99 & 99  \\ \hline
        18 & 21 & 26 & 66 & 99 & 99 & 99 & 99  \\ \hline
        24 & 26 & 56 & 99 & 99 & 99 & 99 & 99  \\ \hline
        47 & 66 & 99 & 99 & 99 & 99 & 99 & 99  \\ \hline
        99 & 99 & 99 & 99 & 99 & 99 & 99 & 99  \\ \hline
        99 & 99 & 99 & 99 & 99 & 99 & 99 & 99  \\ \hline
        99 & 99 & 99 & 99 & 99 & 99 & 99 & 99  \\ \hline
        99 & 99 & 99 & 99 & 99 & 99 & 99 & 99  \\ \hline  	  
    \end{tabularx}
    \caption{Beispiel Quantisierungstabelle für Luminanz (links) und Chominanzen
        \label{jpeg:tab:quant}}
\end{table}



\subsection{Umsortierung und Differenzkodierung
\label{jpeg:subsection:umsortierung}}
Die 64 Koeffizienten des Pixelblocks werden nach der Quantisierung im Zig-Zag Muster abgetastet wie in ABB. \ref{jpeg:fig:zigzag} zeigt.
Die linke obere Ecke ist der Gleichanteil (DC-Wert), das ist die mittlere Helligkeit des Blocks.
Der Rest ist der Wechselanteil (AC-Wert), wenn man den Zig-Zag folgt erreicht man den mit der höchsten Frequenz zuletzt.

Die Koeffizienten mit hohem Wert (die kleinen Frequenzen) stehen nun am Anfang und die kleine weiter hinten.
Je stärker quantisiert wurde desto mehr nullen sind am Ende, was für eine Lauflängenkodierung optimal ist.

\begin{figure}
    \centering
    \includegraphics[width=75mm]{papers/jpeg/pictures/zigzag.pdf}
    \caption{Zig-Zag abtastung der Koeffizienten
        \label{jpeg:fig:zigzag}}
\end{figure}

Zudem wird der DC-Wert noch mit dem Block links davon jeweils differenziell kodiert, damit man weiss wie die einzeln transformierten und quantisierten Blöcke zusammenhängen.
Wobei der erste Block mit dem dazugehörigen DC-Wert anfängt.

Aus dem Beispielausschnitt aus Tabelle \ref{jpeg:tab:quantblock} wird vom DC-Wert 69 der Wert des vorherigen Blocks (71) abgezogen das sind in diesem Beispiel \(69-76 = -7\).

\subsection{Entropiekodierung
\label{jpeg:subsection:entropiekodierung}}
Der DC- und die AC-Werte werden einzel behandelt.
Der differenzkodierte Gleichanteil wird direkt mit einem Huffmantree kodiert und um Daten zu sparen werden die AC-Werte zuerst run-lengthen coding (RLC) und danach mit einem weiteren Huffmantree kodiert in Abb. \ref{jpeg:fig:huffman} sind die Bäume dargestellt.
Der JPEG-Standard gibt auch hier keinen Huffmantree vor, dieser muss also auch im File header hinterlegt werden.

Die RLC der Wechselanteile erfolgt in einer Klammer Sortierung, der erste in der Klammer gibt an wievile AC-Werte davor Null sind und der zweite Anzahl zum kodieren.
Darauf folgt der AC-Wert selbst also 
\begin{equation}
    [(0,3)5],[(0,2)-2], \dots, [(2,1)-1], EOB.
\end{equation}
Nach dem letzten Wert \(\neq 0\) wird als Abschluss der End-of-Block (EOB) als (0,0) definiert.

Bei der Huffman Kodierung ist von jedem Knoten nach links 0 und rechts 1, um den Wert 4 zu erhalten braucht man die Bitfolge 101.
Um aus der Kodierung den Wert zu erhalten muss bei jedem Konten weiter gegangen werden bis man ein Ende erreicht (z.B. 1110 entspricht 6).

Nun kann man mit Hilfe von den Tabellen und Bäumen den Bitstream für diesen Pixelblock erstellen.
Der DC-Wert -7 hat die binäre Länge 3, aus dem Baum ergibt sich ein 100 und aus der Tabelle \ref{jpeg:tab:huffman} den binären Wert 000 zusammen ist das 100000.
Für die AC-Werte werden nun die Kette aus der RLC mit dem zweiten Baum in Bits umgewandelt.
Die Klammer (0,3) hat aus dem Baum den Wert 100 und die 5 als binären Wert 101, was 100101 ergibt, wird das mit allen Werten gemacht erhält man
\begin{equation}
    1000'0010'0101'0101'0000'0000'0001'1110'0011'1000'1010    
\end{equation}
diesen Bitstream.
Die ersten 6 Bits sind aus dem DC-Wert der rest aus dem AC teil.

Der Bitstream besteht aus 44 Bits, hätte man die Werte aus Tabelle \ref{jpeg:tab:quantblock} genommen bräuchte man \(8\times8\times8=512\) Bits, aus 8x8 Einträgen mit jeweils 8 Bit lange, was dem 11-fachen entspricht.
 

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{papers/jpeg/pictures/huffman.pdf}
    \caption{Huffman-Baum für DC-Wert(links) und AC-Wert als Dupel 
        \label{jpeg:fig:huffman}}
\end{figure}

\begin{table}[b]
    \centering
    \begin{tabular}{lcl}
        L & Eintrag                     & Binär\\
        0 & 0                           & - \\
        1 & -1,1                        & 0,1 \\
        2 & -3,-2,2,3                   & 00,01,10,11 \\
        3 & -7,-6,-5,-4,4,5,6,7         & 000,001,010,011,100,101,110,11 \\
        4 & -15,-14,\dots,-8,8,\dots,15 & 0000,0001,\dots,0111,1000,\dots,1111 \\
        5 & \dots                       & \dots \\
        6 & \dots                       & \dots                           
    \end{tabular}
    \caption{Beispiel für einen Huffman-Code
        \label{jpeg:tab:huffman}}
\end{table}
